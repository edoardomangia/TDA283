#ifndef TYPECHECKER_H
#define TYPECHECKER_H

#include "Absyn.H"
#include <map>
#include <stack>
#include <string>
#include <vector>
#include <stdexcept>
#include <iostream>

/** Our internal enumeration of types. */
enum BaseType {
    TYPE_INT,
    TYPE_DOUBLE,
    TYPE_BOOL,
    TYPE_VOID,
    TYPE_ERR // optional: a sentinel for errors, if you like
};

/** 
 * Represents a function signature: return type + parameter types.
 */
struct FnSignature {
    BaseType returnType;
    std::vector<BaseType> paramTypes;
};

/** 
 * The TypeChecker class implements the Visitor interface generated by BNFC
 * and performs a complete type check over the Javalette AST.
 */
class TypeChecker : public Visitor {
public:
    /** 
     * For variables, we use a stack of scopes:
     * Each scope is a map from variable name to BaseType.
     */
    std::stack< std::map<std::string, BaseType> > varScopes;

    /**
     * For functions, map from name -> FnSignature (return type + param types).
     */
    std::map<std::string, FnSignature> functionTable;

    /** 
     * Tracks the type of the most recently visited expression.
     * e.g., after visiting EAdd(...), we store the type of that expression here.
     */
    BaseType currentExprType;

    /**
     * Tracks the return type of the current function we're type-checking.
     * This is needed so we can validate 'return' statements.
     */
    BaseType currentFunctionReturnType;

    /**
     * Did we see a 'return' in the current function?
     * This helps us ensure that a non-void function always returns something.
     */
    bool sawReturnInCurrentFunction;

    /**************************************************************
     *               Constructor / Destructor
     **************************************************************/
    TypeChecker();
    virtual ~TypeChecker();

    /**
     * Entry point: checks the entire Program node.
     * 1) Gather all function signatures (first pass)
     * 2) Type-check each function body (second pass)
     * Returns the same AST if successful, throws if any error.
     */
    Program* checkProgram(Program *program);

    /**************************************************************
     *          Helper Methods
     **************************************************************/
    /** Convert a BNFC Type node (Int, Doub, Bool, Void, Fun, ...) to our BaseType. */
    BaseType convertType(Type *t);

    /** Enter a new scope: push a fresh map for variables on varScopes. */
    void enterScope();

    /** Leave the current scope: pop varScopes. */
    void leaveScope();

    /**
     * Declare a new variable in the current scope. 
     * Throws if the variable already exists in this scope.
     */
    void declareVariable(const std::string &name, BaseType t);

    /**
     * Lookup a variable in the scopes. Returns the type, or throws if not found.
     */
    BaseType lookupVariable(const std::string &name);

    /**
     * A helper to check if two types are exactly the same (int == int, etc.)
     * or if we allow any specific conversions. For now, we require exact match.
     */
    bool sameType(BaseType a, BaseType b) { return a == b; }

    /**
     * A helper to check if the type is numeric (int or double).
     */
    bool isNumeric(BaseType t) { return (t == TYPE_INT || t == TYPE_DOUBLE); }

    /**
     * A helper to unify numeric expressions: 
     * - if both are int => result is int
     * - if both are double => result is double
     * - if one int, one double => result is double (optionally allow promotion)
     *   or else you can forbid mixing int/double if thatâ€™s the assignment.
     */
    BaseType unifyNumeric(BaseType left, BaseType right);

    /**************************************************************
     *          Visitor Methods in BNFC (order from Javalette.cf)
     **************************************************************/

    /* 1) Program */
    virtual void visitProgram(Program *p) override;

    /* 2) TopDef */
    virtual void visitFnDef(FnDef *p) override;
    virtual void visitListTopDef(ListTopDef *p) override;

    /* 3) Arg */
    virtual void visitArgument(Argument *p) override;
    virtual void visitListArg(ListArg *p) override;

    /* 4) Blk */
    virtual void visitBlock(Block *p) override;

    /* 5) Stmt */
    virtual void visitEmpty(Empty *p) override;
    virtual void visitBStmt(BStmt *p) override;
    virtual void visitDecl(Decl *p) override;
    virtual void visitNoInit(NoInit *p) override;
    virtual void visitInit(Init *p) override;
    virtual void visitAss(Ass *p) override;
    virtual void visitIncr(Incr *p) override;
    virtual void visitDecr(Decr *p) override;
    virtual void visitRet(Ret *p) override;
    virtual void visitVRet(VRet *p) override;
    virtual void visitCond(Cond *p) override;
    virtual void visitCondElse(CondElse *p) override;
    virtual void visitWhile(While *p) override;
    virtual void visitSExp(SExp *p) override;
    virtual void visitListStmt(ListStmt *p) override;

    /* 6) Item */
    virtual void visitListItem(ListItem *p) override;

    /* 7) Type */
    virtual void visitInt(Int *p) override;
    virtual void visitDoub(Doub *p) override;
    virtual void visitBool(Bool *p) override;
    virtual void visitVoid(Void *p) override;
    virtual void visitFun(Fun *p) override; 
    virtual void visitListType(ListType *p) override; 

    /* 8) Expr */
    virtual void visitEVar(EVar *p) override;
    virtual void visitELitInt(ELitInt *p) override;
    virtual void visitELitDoub(ELitDoub *p) override;
    virtual void visitELitTrue(ELitTrue *p) override;
    virtual void visitELitFalse(ELitFalse *p) override;
    virtual void visitEApp(EApp *p) override;
    virtual void visitEString(EString *p) override;
    virtual void visitNeg(Neg *p) override;
    virtual void visitNot(Not *p) override;
    virtual void visitEMul(EMul *p) override;
    virtual void visitEAdd(EAdd *p) override;
    virtual void visitERel(ERel *p) override;
    virtual void visitEAnd(EAnd *p) override;
    virtual void visitEOr(EOr *p) override;
    virtual void visitListExpr(ListExpr *p) override;

    /* 9) AddOp */
    virtual void visitPlus(Plus *p) override;
    virtual void visitMinus(Minus *p) override;

    /* 10) MulOp */
    virtual void visitTimes(Times *p) override;
    virtual void visitDiv(Div *p) override;
    virtual void visitMod(Mod *p) override;

    /* 11) RelOp */
    virtual void visitLTH(LTH *p) override;
    virtual void visitLE(LE *p) override;
    virtual void visitGTH(GTH *p) override;
    virtual void visitGE(GE *p) override;
    virtual void visitEQU(EQU *p) override;
    virtual void visitNE(NE *p) override;

    /**************************************************************
     *     Leaf Tokens & Unused visitor methods
     **************************************************************/
    virtual void visitProg(Prog *p) override {}
    virtual void visitTopDef(TopDef *p) override {}
    virtual void visitArg(Arg *p) override {}
    virtual void visitBlk(Blk *p) override {}
    virtual void visitStmt(Stmt *p) override {}
    virtual void visitItem(Item *p) override {}
    virtual void visitType(Type *p) override {}
    virtual void visitExpr(Expr *p) override {}
    virtual void visitAddOp(AddOp *p) override {}
    virtual void visitMulOp(MulOp *p) override {}
    virtual void visitRelOp(RelOp *p) override {}

    virtual void visitInteger(Integer x) override {}
    virtual void visitChar(Char x) override {}
    virtual void visitDouble(Double x) override {}
    virtual void visitString(String x) override {}
    virtual void visitIdent(Ident x) override {}
};

#endif

